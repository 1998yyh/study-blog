# 正则表达式回溯法原理

学习正则表达式，是需要懂点儿匹配原理的。 而研究匹配原理时，有两个字出现的频率比较高:“回溯”。 听起来挺高大上，事实上却是一个比较容易理解的概念。


## 没有回溯的匹配

假设我们的正则是 `/ab{1,3}c/`

而当目标字符串是 "abbbc" 时，就没有所谓的“回溯”。


## 有回溯的匹配

如果目标字符串是"abbc"，中间就有回溯。 匹配到第三个b 没有的时候会回朔 第二个就可以了.

回溯法也称试探法，它的基本思想是:从问题的某一种状态(初始状态)出发，搜索从这种状态出发 所能达到的所有“状态”，当一条路走到“尽头”的时候(不能再前进)，再后退一步或若干步，从 另一种可能“状态”出发，继续搜索，直到所有的“路径”(状态)都试探过。这种不断“前进”、 不断“回溯”寻找解的方法，就称作“回溯法”。

JavaScript 中正则表达式会产生回溯的地方都有哪些呢?


```js
var string = "12345";
var regex = /(\d{1,3})(\d{1,3})/;
console.log( string.match(regex) );
// => ["12345", "123", "45", index: 0, input: "12345"]
```


当我们加了惰性量词的时候.表示尽可能少的匹配.比如匹配如下字符串
```js
var string = "12345";
var regex = /(\d{1,3}?)(\d{1,3})/;
console.log( string.match(regex) );
// => ["1234", "1", "234", index: 0, input: "12345"]

```


虽然惰性量词不贪，但也会有回溯的现象。比如正则是:

```js
var string = "12345";
var regex = /^(\d{1,3}?)(\d{1,3})$/;
console.log( string.match(regex) );
// => ["12345", "12", "345", index: 0, input: "12345"]
```


## 分支结构的匹配


