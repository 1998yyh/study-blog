# pnpm

## 包管理工具发展

### npm2

node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。

然后执行 npm install express，那么 express 包和它的依赖都会被下载下来,展开 express，它也有 node_modules,再展开几层，每个依赖都有自己的 node_modules


* 这样的问题在于 多个包之间会有重复的公共依赖,这样会引入多次,会占据较大的磁盘空间.

* 致命问题是 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的


### yarn npm3

他们的解决方式是铺平在同一层.这样就没有依赖重复多次的问题了

全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的 ,部分也会存在第二层 因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。

最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。

这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。


## pnpm

回想下 npm3 和 yarn 为什么要做 node_modules 扁平化？不就是因为同样的依赖会复制多次，并且路径过长在 windows 下有问题么？

那如果不复制呢，比如通过 link。

首先介绍下 link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。

如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？

这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。

pnpm 就是通过这种思路来实现的。

比如我们调用 `pnpm install express`时候,会输出

```JS
// Packages are hard linked from the content-addressable store to the virtual store.
// 包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules/.pnpm。

// Progress: resolved 59, reused 57, downloaded 0, added 57, done
// 说明磁盘里已经有了相应的包了 reused 57 复用了 57个 然后添加软连接到node_modules上
```

但是这样容易造成全局磁盘堆积,需要我们定期清理一下,全局缓存 pnpm store prune 



## 扩展

### 软连接

又被叫为符号链接（symbolic  Link），它包含了到原文件的路径信息。

#### 特性

（1）软链接有自己的文件属性及权限等；

（2）可对不存在的文件或目录创建软链接；

（3）软链接可交叉文件系统；

（4）软链接可对文件或目录创建；

（5）创建软链接时，链接计数 i_nlink 不会增加；`ln -s file link`

（6）删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。


### 硬连接

是对原文件起了一个别名。

#### 特性

（1）文件有相同的 inode 及 data block；

（2）只能对已存在的文件进行创建；

（3）不能交叉文件系统进行硬链接的创建；

（4）不能对目录进行创建，只可对文件创建；`ln file link`

（5）删除一个硬链接文件并不影响其他有相同inode 号的文件。


### 区别

1. 本质:硬连接是同一个文件 软连接不是同一个文件

2. 跨设备 软连接支持 硬连接不支持

3. inode 硬连接相同 软连接不同



