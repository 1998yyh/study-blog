# 性能优化

## 方向

1. 过程趋势： 网络层面，渲染层面。

2. 结果趋势： 时间层面，体积层面

## 指标

1. 首屏渲染时间

SPA首屏渲染时间使用performance 并不一定准确。

应该使用fetchStart + MutationObserve

2. 白屏时间

页面开始展示的时间点 - 开始时间点

FP = domloading - navigationStart;

3. 卡顿

卡顿 FPS 单帧渲染耗时

FPS是否稳定

标准为连续3帧 不低于20FPS

页面加载了x ms
计算方式 1000ms 执行了 多少n次requestAnimation Frame

4. 网络环境数据

拿到两张不同尺寸的加载事件

在请求图片之前打一个时间点，图片onload完之后再打一个时间点，

文件体积 / 加载事件就可以获取到大概的网速了。

5. TBT

总阻塞时间 (TBT) 指标测量First Contentful Paint 首次内容绘制 (FCP)与Time to Interactive 可交互时间 (TTI)之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。

每当出现长任务（在主线程上运行超过 50 毫秒的任务）时，主线程都被视作"阻塞状态"。我们说主线程处于"阻塞状态"是因为浏览器无法中断正在进行的任务。因此，如果用户在某个长任务运行期间与页面进行交互，那么浏览器必须等到任务完成后才能作出响应。

如果任务时长足够长（例如超过 50 毫秒），那么用户很可能会注意到延迟，并认为页面缓慢或卡顿。

某个给定长任务的阻塞时间是该任务持续时间超过 50 毫秒的部分。一个页面的总阻塞时间是在 FCP 和 TTI 之间发生的每个长任务的阻塞时间总和。

详细解析地址: <https://web.dev/tbt/?utm_source=devtools>

## 方案

#### 网络层面

构建策略：基于构建工具(Webpack/Rollup/Parcel/Esbuild/Vite/Gulp)
图像策略：基于图像类型(JPG/PNG/SVG/WebP/Base64)
分发策略：基于内容分发网络(CDN)
缓存策略：基于浏览器缓存(强缓存/协商缓存)

##### 构建策略

说到webpack的性能优化，无疑是从时间层面和体积层面入手

减少打包时间：缩减范围、缓存副本、定向搜索、提前构建、并行构建、可视结构
减少打包体积：分割代码、摇树优化、动态垫片、按需加载、作用提升、压缩资源

1. 配置include/exclude缩小Loader对文件的搜索范围，好处是避免不必要的转译。

2. 配置cache缓存Loader对文件的编译副本，好处是再次编译时只编译修改过的文件

3. 配置resolve提高文件的搜索速度，好处是定向指定必须文件路径

4. 配置DllPlugin将第三方依赖提前打包，好处是将DLL与业务代码完全分离且每次只构建业务代码

5. 配置Thread将Loader单进程转换为多进程，好处是释放CPU多核并发的优势

6. 配置BundleAnalyzer分析打包文件结构，好处是找出导致体积过大的原因

7. 分割各个模块代码，提取相同部分代码，好处是减少重复代码的出现频率

8. 删除项目中未被引用代码，好处是移除重复代码和未使用代码

摇树优化只对ESM规范生效，对其他模块规范失效。摇树优化针对静态结构分析，只有import/export才能提供静态的导入/导出功能。因此在编写业务代码时必须使用ESM规范才能让摇树优化移除重复代码和未使用代码。

在webpack里只需将打包环境设置成生产环境就能让摇树优化生效，同时业务代码使用ESM规范编写，使用import导入模块，使用export导出模块。

9. 通过垫片服务根据UA返回当前浏览器代码垫片，好处是无需将繁重的代码垫片打包进去。动态垫片可根据浏览器UserAgent返回当前浏览器Polyfill，其思路是根据浏览器的UserAgent从browserlist查找出当前浏览器哪些特性缺乏支持从而返回这些特性的Polyfill

10. 将路由页面/触发性功能单独打包为一个文件，使用时才加载，好处是减轻首屏渲染的负担

11. 分析模块间依赖关系，把打包好的模块合并到一个函数中，好处是减少函数声明和内存花销

12. 压缩HTML/CSS/JS代码，压缩字体/图像/音频/视频，好处是更有效减少打包体积

##### 图像策略

该策略主要围绕图像类型做相关处理，同时也是接入成本较低的性能优化策略。只需做到以下两点即可。

1. 图像选型：了解所有图像类型的特点及其何种应用场景最合适
2. 图像压缩：在部署到生产环境前使用工具或脚本对其压缩处理

##### 分发策略

1. 所有静态资源走CDN：开发阶段确定哪些文件属于静态资源

2. 把静态资源与主页面置于不同域名下：避免请求带上Cookie

##### 缓存策略

减少网络传输所带来的损耗，提升网页访问速度

- 考虑拒绝一切缓存策略：Cache-Control:no-store
- 考虑资源是否每次向服务器请求：Cache-Control:no-cache
- 考虑资源是否被代理服务器缓存：Cache-Control:public/private
- 考虑资源过期时间：Expires:t/Cache-Control:max-age=t,s-maxage=t
- 考虑协商缓存：Last-Modified/Etag

#### 渲染层面

渲染层面的性能优化，无疑是如何让代码解析更好执行更快。

CSS策略：基于CSS规则
DOM策略：基于DOM操作
阻塞策略：基于脚本加载
回流重绘策略：基于回流重绘
异步更新策略：基于异步更新

##### CSS策略

避免出现超过三层的嵌套规则
避免为ID选择器添加多余选择器
避免使用标签选择器代替类选择器
避免使用通配选择器，只对目标节点声明规则
避免重复匹配重复定义，关注可继承属性

##### DOM策略

缓存DOM计算属性
避免过多DOM操作
使用DOMFragment缓存批量化DOM操作

##### 阻塞策略

脚本与DOM/其它脚本的依赖关系很强：对<script>设置defer
脚本与DOM/其它脚本的依赖关系不强：对<script>设置async

##### 异步更新策略

在异步任务中修改DOM时把其包装成微任务
