# mysql 优化


## 一条SQL的生命周期


### MYsql客户端

一条 SQL 执行的第一步是由 MySQL 客户端发送到 MySQL 服务端。

MySQL 客户端成功连接 MySQL 服务端之后，MySQL 服务端的连接池会对客户端的连接进行权限验证，当权限验证通过之后，MySQL 服务端会将客户端的链接记录在服务端的连接池中，之后的各种操作将不再进行权限认证。

这里你肯定会有疑问：为什么 MySQL 要增加一个连接池模块呢？直接连接 MySQL 服务端不是更简单且高效吗？下面我们就来分析一下。

每一次操作数据库，都需要有一个 MySQL 客户端和服务端之间的链接，创建一个链接就会有一定的时间消耗；当在高并发的情况下，每一次访问数据都会创建一个链接，这样就会持续创建很多重复的数据库链接，很没有必要而且大量的创建链接可能会导致数据库内存溢出等问题。

为了解决这个问题，MySQL 数据库就提供了一个链接池模块，主要用来保存和安全校验连接过来的客户端，当一个客户端连接成功之后，并不会立即释放该连接，而是会将该链接保存在连接池中，这样下一次同一个客户端连接过来就不需要再重复创建连接和安全验证了，可以在很大程度上降低数据库的资源消耗并且减少连接数据的延时。


### MySQL服务器

在 MySQL 服务端中，SQL 执行过程中是需要经过很多模块的，其中比较重要的模块是缓存、SQL 解析器、查询优化器以及 SQL 执行器等模块。


1. 在 MySQL 数据库中，如果开启了缓存查询，每一次的查询都会在缓存器中以 KV 形式缓存一份。一条 SQL 在执行过程中，如果命中了缓存，就会跳过 SQL 解析器、查询优化器以及 SQL 执行器，并且立即返回数据，这样做的目的主要是提高数据库的性能。
2. SQL 解析器的主要功能是解析客户端发送过来的 SQL，就比如匹配到 SQL 中是以 select 开头的，那就可以认定其为查询语句；以 insert 开头的 SQL，就可以认定其为插入语句。'
3. 为了找到 SQL 的最佳执行方案。 在 MySQL 数据库中的查询优化器优化 SQL 具体有两个方面，分别是逻辑层面和物理层面。 逻辑层面的优化主要有命中索引优化、顺序优化、排序优化等
4. SQL 执行模块首先会判断当前用户是否对该表有相关的操作权限（如果命中了缓存，将会在返回缓存数据之前进行权限认证）。权限判断通过之后才会调用存储引擎去操作对应的数据表，然后将操作的结果返回。


## count() 速度 

count(*) > count(1) > count(主键) > count(字段)。


在 MySQL 中，统计数据一般情况下会使用 count() 函数。它在不同的存储引擎中的结果是不一样的，主要原因是在支持事务的存储引擎中不同的情况得到的结果不同。如果使用 Redis 作为存储计数结果的对象，是不能够保证计数的精确性的，所以不能使用 Redis 等缓存数据库作为计数结果的存储数据的对象。而不同的 count 使用形式，其计数的结果可能是不一样的，性能也有一些差别。

我们在数据库的实际应用过程中，一般数据量不是特别大的情况下，我们尽量选择使用 count(*) 来统计，因为它是经过算法优化的，性能比其他的 count 形式都要优秀。但是在处理大量的数据统计的情况下，不建议直接使用count(*)，因为它虽然经过优化，还是需要一条一条地统计，数据太大仍然很慢，这个时候我们可以考虑更换性能更加优秀的数据库。


## sql排序流程 

1. 全字段排序

第一步：创建 sort buffer 内存空间。
第二步：首先会根据 WHERE 条件，查询出符合条件的数据（这里指的是 order_price > 100 的所有数据）。
第三步：在符合条件的数据中，通过主键索引取出需要查询的数据并写入 sort buffer 并排序。
第四步：通过第三条中取得的数据的主键，再去获取下一条数据的主键，进而获取下一条数据。
第五步：重复第三和四步，直至取完所有的数据（此时 sort buffer 中只有主键和排序字段并且按照排序字段排好了顺序，如果 sort buffer 空间不足以承载所有的数据时，就需要借助于临时文件进行排序。）。
第六步：通过排好顺序的数据的主键 id，去取所需要的所有数据。
第七步：最后将所有排好序的数据返回。


2. ROWID排序