#  Nuxt.js

## Why SSR for VueJS?

### Faster page loads

使用服务器端呈现的应用程序可以更快地加载页面，从而提高用户体验。由于服务器呈现的标记不需要在显示之前下载并执行所有 JavaScript，因此用户将更快地看到完全呈现的页面。

### Strong SEO

页面内容可能在加载页面之前生成。搜索引擎可以简单地索引和抓取内容时，呈现服务器端，这是完美的搜索引擎优化(搜索引擎优化)。如果在 SEO 至关重要的页面上异步获取内容，则可能需要 SSR。

无论框架如何，服务器端呈现的工作方式都是相同的。当我们通过输入 URL 或刷新页面来浏览页面时，我们从服务器获取标记。然后，当我们访问应用程序时，我们只使用客户端渲染，因为所有必需的 HTML 都已经存在ーー不再需要服务器。整个过程由两个关键组成部分组成: `rendering(渲染)`和`hydration(水合作用)`。

在现代框架中，它由一个专门的函数来处理，该函数将组件呈现为一个字符串，或者由路由器来提供呈现和匹配的组件.

一旦我们在页面上有了想要呈现的组件，我们显然希望异步加载一些数据，这里是我们需要超越框架的地方。

每个需要外部数据的组件通常必须实现一个单独的函数来检索它。我们可以为每个组件执行这个函数，因为我们可以访问呈现的组件，一旦完成所有提取，我们就可以将完成的标记发送给客户端。

浏览器刚刚接收到呈现的 HTML。水合过程现在已经完全控制了。数据及其在 _ INITIALSTATE _ 中的原始表示已经存在于来自服务器的标记中。

水合作用有两个主要目标:
1. 向框架注册接收到的标记,框架会自动运行
2. 将数据分配给适当的客户端属性,框架需要管理,框架将数据分配给服务器端的变量,但是我们需要在客户端重新分配数据.因为我们拥有唯一数据包含在呈现的 HTML 中，或者提供给窗口对象的初始状态。



## 创建Nuxt项目

官网:https://www.nuxtjs.cn/


``` js
npm install -g vue-cli

npm init nuxt-app NuxtApp
```

然后按自己需求配置项目


### nuxt用的css库

布拉巴:https://bulma.io/

感觉和 原子化的css 

https://tailwindcss.com/






