# 工程化


前端工程化就是处理代码的一系列工具链，他们并不关心代码的内容，只是把代码作为字符串来进行一系列处理。编译构建、ci/cd、代码托管、静态分析、格式化等都是。


## 编译

提到前端工程化，最容易想到的就是编译了。

* 高版本的语法需要用 babel 编译成低版本的。

* less、sass 要经过各自的编译器转换成 css 代码。

* TypeScript 代码需要经过 tsc 或者 babel 等编译器转成 JS 代码。

最早的前端工程化是通过任务的形式组织这些编译过程的，指定对什么文件用什么编译器编译，然后输出到哪个目录。任务之间可以规定先后顺序、串行并行。gulp 就是这一类工具，叫做任务运行器（task runner）。

这一类工具能够组织整个编译流程，对不同的文件分别做相应的处理，使之能运行在目标环境。但因为每个任务都比较独立，很难做一些全局的优化。

后来出现了另一种思路，不通过任务组织了，而是分析模块之间的依赖关系，从入口模块开始构建一棵依赖图，中间遇到的用到的 js、css、图片等都会作为他的依赖。然后对依赖图的每个节点分别用对应的编译器处理。

这叫做打包工具（bundler），典型的是 webpack。

但是打包工具也不是完美的，因为每次都要构建整个依赖图，对不同文件分别做处理，之后才能生成代码，所以当项目的模块多了就会很慢，大项目打包几分钟也是很常见的事情。

有痛点问题，大家就会想办法去解决，所以出现了 no bundle 的方案，也就是不打包，比如 vite。

no bundle 是基于浏览器支持 es module 来实现的，浏览器会做 es module 的依赖分析，然后加载对应的模块，这样自然就不用自己做依赖分析了，只需要实现模块的编译即可。所以，no bundle 工具会启动一个开发服务器，根据请求的模块路径来进行相应的编译，然后返回编译后的代码。


**构建的核心是对不同的文件做不同的编译，最早的任务运行器的方案实现了编译流程的组织，但是并没有做全局的优化，也没有自己的 runtime 代码，所以出现了基于依赖分析的打包工具，打包工具可以基于依赖分析实现 treeshking、code splitting 等优化，可以配合 runtime 代码实现 lazy load。但成也依赖分析，败也依赖分析，这个太慢了，所以出现了 no bundle 的方案，配合浏览器对 es module 的支持，只要实现对应模块的编译服务即可，不过生产环境还是要打包的。**


## 规范

* JS 代码会用 ESLint 来禁止掉一些写法，比如 concole、debugger 的使用，还可以修复格式问题，比如缩进方式，还能检查出一些逻辑错误，比如 if 中用了赋值。

* CSS 代码也同样会用 StyleLint 来禁用一些写法，修复格式问题，检查出一些逻辑错误

* ESLint、StyleLint 只是局部的格式修复，我们还可以用 prettier 来进行整体的格式化

* 如果我们用了 TypeScript，那就可以用 tsc 来进行类型检查，发现代码中潜在的类型不匹配的错误


静态分析工具、格式化工具并不影响构建，他们一般是单独来跑的，用来发现一些代码潜在的问题，规范代码格式等。
代码写完之后，会上传到代码仓库，比如 gitlab，代码托管也是工程化的一部分。
代码上线的话，需要进行构建和部署，我们可以通过 jenkins 来组织构建流程，当 gitlab 代码有新的 push 的时候触发，进行构建，然后把产物部署到服务器，基于 git hook 的构建部署流程就叫做持续集成、持续部署（CI/CD）。这也是前端工程化的一部分。
